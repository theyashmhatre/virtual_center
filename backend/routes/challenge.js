const router = require("express").Router();
const express = require("express");
const mysqlConnection = require("../config/dbConnection");
const { route } = require("./user");
const createChallengeValidation = require("../utils/validation/create-challenge");
const upload = require("../config/multerConfig");
const { generateCurrentDateTime } = require("../utils/utils");
const passport = require("passport");

router.get("/", (req, res) => {
  res.status(200).send("Challenge");
});

router.post(
  "/create-challenge",
  [
    passport.authenticate("jwt", { session: false }),
    upload.single("cover_image"),
  ],
  (req, res) => {
    try {
      const { errors, isValid } = createChallengeValidation(req);

      if (!isValid) return res.status(400).json(errors);

      const {
        challengeName,
        challengeDescription,
        userId,
        endDate,
        tags,
        supportingMedia,
        reward,
      } = req.body;

      const coverImage = req.file.filename; //filename generated by muter middleware
      const postedOn = generateCurrentDateTime();

      const newChallenge = {
        name: challengeName,
        description: challengeDescription,
        user_id: userId,
        cover_image: req.file.filename,
        posted_on: postedOn,
        end_date: endDate,
        status: true,
      };

      //converting comma(,) separated string into a list
      let tagValues = tags.split(",").map(function (item) {
        return [item.trim()];
      });

      //MySQL transaction begins
      mysqlConnection.beginTransaction(function (err) {
        if (err) {
          return res.status(500).json({
            main: "Something went wrong",
            devError: sqlErr,
            devMsg: "Error occured while adding challenge into db",
          });
        }

        //Inserting all tags into 'tag' table. Ignore a tag if already inserted. 'name' in Tag table should be set to unique.
        mysqlConnection.query(
          `INSERT IGNORE INTO tag (name) VALUES ?`,
          [tagValues],
          (sqlErr, result, fields) => {
            if (sqlErr) {
              return mysqlConnection.rollback(function () {
                throw sqlErr;
              });
            }

            //Creating a new challenge
            mysqlConnection.query(
              `INSERT INTO challenge SET ?`,
              newChallenge,
              (sqlErr, result, fields) => {
                if (sqlErr) {
                  return mysqlConnection.rollback(function () {
                    throw sqlErr;
                  });
                }

                newChallengeId = result.insertId;

                //Individually inserting challenge_id and tag_id of each of the tags associated with the challenge inside a 'tag_map' table
                mysqlConnection.query(
                  `INSERT INTO tag_map (challenge_id, tag_id) SELECT ${newChallengeId}, t.tag_id from tag t WHERE t.name IN ?`,
                  [[tagValues]],
                  (sqlErr, result, fields) => {
                    if (sqlErr) {
                      return mysqlConnection.rollback(function () {
                        throw sqlErr;
                      });
                    }

                    //Commit transaction
                    //All the changes by the previous queries will be accepted into the database only if this function executes else everything returns back to original state
                    mysqlConnection.commit(function (error) {
                      if (error) {
                        return mysqlConnection.rollback(function () {
                          throw error;
                        });
                      }

                      return res
                        .status(201)
                        .json({ devMsg: "New challenge created successfully" });
                    });
                  }
                );
              }
            );
          }
        );
      });
    } catch (error) {
      console.log(error);
      return res.status(500).json({
        main: "Something went wrong",
        devError: error,
        devMsg: "Error occured while creating challenge",
      });
    }
  }
);

router.get(
  "/get-single-challenge/:challengeId",
  passport.authenticate("jwt", { session: false }),
  (req, res) => {
    try {
      let { challengeId } = req.params;

      if (!challengeId)
        return res
          .status(400)
          .json({ main: "Invalid Request", devMsg: "No challenge id found" });

      //query to find single challenge
      mysqlConnection.query(
        `SELECT * from challenge where challenge_id = ${challengeId}`,
        (sqlErr, result, fields) => {
          if (sqlErr) {
            console.log(sqlErr);
            return res.status(500).json({
              main: "Something went wrong",
              devError: sqlErr,
              devMsg: "Error occured while fetching challenge from db",
            });
          } else if (!result[0]) {
            console.log("No challenge found");
            return res.status(200).json({
              main: "Challenge you were looking for doesn't exist.",
              devError: "Challenge not found in database",
            });
          } else {
            let challenge = result[0];
            console.log("Challenge fetched", result);

            return res.status(200).json(challenge);
          }
        }
      );
    } catch (error) {
      console.log(error);
      return res.status(500).json({
        main: "Something went wrong",
        devError: error,
        devMsg: "Error occured while fetching challenge",
      });
    }
  }
);

router.get(
  "/get-challenges/:pageNum",
  passport.authenticate("jwt", { session: false }),
  (req, res) => {
    try {
      const { pageNum } = req.params; //current page number

      const limit = 5; //number of items to be sent per request

      const offset = (pageNum - 1) * limit; //number of rows to skip before selecting records

      mysqlConnection.query(
        `SELECT * from challenge LIMIT ? OFFSET ?`,
        [limit, offset],
        (sqlErr, result, fields) => {
          if (sqlErr) {
            console.log(sqlErr);
            return res.status(500).json({
              main: "Something went wrong",
              devError: sqlErr,
              devMsg: "Error occured while fetching challenge from db",
            });
          } else if (!result.length) {
            return res.status(200).json({ main: "No challenges found." });
          } else {
            let data = {
              challenges_count: result.length,
              page_number: pageNum,
              challenge_list: result,
            };

            res.status(200).json(data);
          }
        }
      );
    } catch (error) {
      console.log(error);
      return res.status(500).json({
        main: "Something went wrong",
        devError: error,
        devMsg: "Error occured while fetching challenges",
      });
    }
  }
);

router.get(
  "/get-challenges-using-tags/:tagsArray",
  passport.authenticate("jwt", { session: false }),
  (req, res) => {
    try {
      let { tagsArray } = req.params;

      tagsArray = JSON.parse(tagsArray);

      if (!tagsArray)
        return res
          .status(400)
          .json({ main: "Invalid Request", devMsg: "No tag found in request" });

      //Selects all fields from challenges
      //checks for intersecting records in tag_map & tag table, tag_map & challenge table
      //works as an Union (OR) query for multiple tags
      mysqlConnection.query(
        `SELECT c.* from tag_map tm, challenge c, tag t 
            WHERE tm.tag_id = t.tag_id 
            AND (t.name IN ?) 
            AND c.challenge_id = tm.challenge_id 
            GROUP BY c.challenge_id`,

        [[tagsArray]],
        (sqlErr, result, fields) => {
          if (sqlErr) {
            console.log(sqlErr);
            return res.status(500).json({
              main: "Something went wrong",
              devError: sqlErr,
              devMsg: "Error occured while fetching challenge from db",
            });
          } else if (!result.length) {
            return res.status(200).json({ main: "No challenges found." });
          } else {
            let challenges = result;
            return res.status(200).json(challenges);
          }
        }
      );
    } catch (error) {
      return res.status(500).json({
        main: "Something went wrong",
        devError: error,
        devMsg: "Error occured while fetching challenges using tags",
      });
    }
  }
);

module.exports = router;
